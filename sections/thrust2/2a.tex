\subsubsection{Task 2.a.} 
We first focus on warps/shared memory.
%
We will address the challenges with respect to global memory next.
%
We propose designing a flow-sensitive type system to capture the taint level propagation by running each thread.
%
The judgment is of the form.
%
$\Psi; \Sigma, \pc \vdash s \dashv \Sigma'$.


$\Sigma$ is the pre-context, corresponding to the types and security levels before running $s$,
$\Sigma'$ is the post-context, corresponding to the types and security levels after running $s$.
%
We assume that the types remain the same before and after, but the security levels can change by wiritng on them.
%
% To account for the low-integrity writes, we consider a taint level consisting of a pair $\langle c, i \rangle$, where $c$ is the security level and $i$ is the integrity level.
%
% Each judgment comes with a security level $\mathsf{sec}$, which is the level of security of the kernel, this corresponds to the amount of secret that they are allowed to know.
%
We also assume a lattice $\Psi$.
%
We fix one lattice and drop $\Psi$ fromthe judgments for clarity.
%
We provide a more fine-grained security for each element of shared memory.
%
Here we list a few sample rules:

Writing a constant $\mathsf{c}$ on a shared location indexed with a constant $\mathsf{c}'$, brings the level to $\mathsf{pc}$.
\farzaneh{what if the index is not constant? Is the second rule ok? What if shared memory is dynamically allocated?}
\begin{mathpar}
\infer*[Right=]{S:\tau\in \Sigma \\
\Sigma \vdash  c: \tau\\
\Sigma \vdash \mathsf{c}': \mathsf{int}
 }{\Sigma,  S[\mathsf{c}']:x, \pc \vdash S[\mathsf{c}']\leftarrow \mathsf{c} \dashv \Sigma,  S[\mathsf{c}']:\pc}
\end{mathpar}


\begin{mathpar}
    \infer*[Right=]{S:\tau\in \Sigma \\ \Sigma \vdash c: \tau\\
    x= \bigvee_{1 \le i \le n} x_i
     }{\Sigma,  S[1]:x_1, \cdots, S[n]:x_n, \pc \vdash S[\mathsf{tid}]\leftarrow \mathsf{c} \dashv \Sigma, S[1]:x \vee \pc, \cdots, S[n]:x \vee \pc}
    \end{mathpar}



The more general rule is:
    \begin{mathpar}
        \infer*[Right=]{S:\tau\in \Sigma \\ \Sigma \vdash e: \tau[y]\\
        \mathsf{c}': \mathsf{int}
         }{\Sigma,  S[\mathsf{c}']:x, \pc \vdash S[\mathsf{c}']\leftarrow e \dashv \Sigma,  S[\mathsf{c}']:y \vee \pc}
        \end{mathpar}

For the reads from shared memory, we have:

\begin{mathpar}
    \infer*[Right=]{S:\tau\in \Sigma \\ \Sigma \vdash c: \tau\\
    S[e]:x \in \Sigma
     }{\Sigma,  X:w, \pc \vdash X \leftarrow S[e] \dashv \Sigma,  X:x \vee \pc}
\end{mathpar}
    
To account for the interleaving of warps, we need to know how many warps will be allocated. (Or have an upper bound on it?)

